{"version":3,"file":"Arguments.js","sourceRoot":"","sources":["../../src/Arguments.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;IAEI,kBACY,WAAmB,EACnB,gBAAqC;QADrC,gBAAW,GAAX,WAAW,CAAQ;QACnB,qBAAgB,GAAhB,gBAAgB,CAAqB;IAC/C,CAAC;IAEH,0BAAO,GAAP,UAAQ,GAAM;QACV,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,2BAAQ,GAAR;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,0BAAO,GAAP;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IACL,eAAC;AAAD,CAAC,AAlBD,IAkBC;AAlBY,4BAAQ;AAoBrB;IAAkC,gCAAa;IAC3C;eACI,kBAAM,OAAO,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI,CAAC;IAC9B,CAAC;IACL,mBAAC;AAAD,CAAC,AAJD,CAAkC,QAAQ,GAIzC;AAJY,oCAAY;AAMzB;IAAA;IA2CA,CAAC;IAxCU,OAAG,GAAV;QACI,OAAO,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,YAAY,EAAE,CAAC,CAAC;IACzD,CAAC;IASM,OAAG,GAAV,UAAW,IAAa;QACpB,IAAM,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,QAAQ,GAAG,IAAI,GAAG,GAAG,CAAC;QAChE,OAAO,IAAI,QAAQ,CAAM,WAAW,EAAE,UAAA,CAAC;YACnC,IAAG,CAAC,IAAI;gBACJ,OAAO,IAAI,CAAC;YAEhB,IAAG,OAAO,CAAC,KAAK,WAAW;gBACvB,OAAO,IAAI,CAAC;YAEhB,IAAG,IAAI,KAAK,OAAO;gBACf,OAAO,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAEjC,OAAO,OAAO,CAAC,KAAK,IAAI,CAAC;QAC7B,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,MAAE,GAAT,UAAa,SAAkC;QAC3C,OAAO,IAAI,QAAQ,CAAI,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,GAAG,EAAE,SAAS,CAAoB,CAAC;IAC5G,CAAC;IAEc,eAAW,GAA1B,UAA2B,GAAQ;QAC/B,IAAG,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;YAChC,OAAO,GAAG,CAAC,OAAO,EAAE,CAAC;QAEzB,IAAG,OAAO,GAAG,CAAC,QAAQ,KAAK,UAAU;YACjC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;QAE1B,OAAO,GAAG,CAAC;IACf,CAAC;IACL,UAAC;AAAD,CAAC,AA3CD,IA2CC;AA3CY,kBAAG","sourcesContent":["export class Argument<T> {\r\n\r\n    constructor(\r\n        private description: string,\r\n        private matchingFunction: (arg: T) => boolean\r\n    ){}\r\n\r\n    matches(arg: T) {\r\n        return this.matchingFunction(arg);\r\n    }\r\n\r\n    toString() {\r\n        return this.description;\r\n    }\r\n\r\n    inspect() {\r\n        return this.description;\r\n    }\r\n}\r\n\r\nexport class AllArguments extends Argument<any> {\r\n    constructor() {\r\n        super('{all}', () => true);\r\n    }\r\n}\r\n\r\nexport class Arg {\r\n    private static _all: AllArguments;\r\n\r\n    static all() {\r\n        return this._all = (this._all || new AllArguments());\r\n    }\r\n\r\n    static any(): Argument<any> & any\r\n    static any<T extends 'string'>(type: T): Argument<string> & string\r\n    static any<T extends 'number'>(type: T): Argument<number> & number\r\n    static any<T extends 'boolean'>(type: T): Argument<boolean> & boolean\r\n    static any<T extends 'array'>(type: T): Argument<any[]> & any[]\r\n    static any<T extends 'function'>(type: T): Argument<Function> & Function\r\n    static any<T extends 'string'|'number'|'boolean'|'symbol'|'undefined'|'object'|'function'|'array'>(type: T): Argument<any> & any\r\n    static any(type?: string): Argument<any> & any {\r\n        const description = !type ? '{any arg}' : '{type ' + type + '}';\r\n        return new Argument<any>(description, x => {\r\n            if(!type)\r\n                return true;\r\n\r\n            if(typeof x === 'undefined')\r\n                return true;\r\n\r\n            if(type === 'array')\r\n                return x && Array.isArray(x);\r\n\r\n            return typeof x === type;\r\n        });\r\n    }\r\n\r\n    static is<T>(predicate: (input: any) => boolean): Argument<T> & T {\r\n        return new Argument<T>('{predicate ' + this.toStringify(predicate) + '}', predicate) as Argument<T> & T;\r\n    }\r\n\r\n    private static toStringify(obj: any) {\r\n        if(typeof obj.inspect === 'function')\r\n            return obj.inspect();\r\n\r\n        if(typeof obj.toString === 'function')\r\n            return obj.toString();\r\n\r\n        return obj;\r\n    }\r\n}"]}